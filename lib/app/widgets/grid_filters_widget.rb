class GridFiltersWidget < Apotomo::Widget
  include GridWidget::ControllerMethods
  include GridWidget::CustomDisplayMethods
  include GridWidget::AppSupport::ControllerMethods
  helper GridWidget::HelperMethods
  helper GridWidget::AppSupport::HelperMethods
    
  # Updated for apotomo 1.2.
  after_initialize do |me|
      me.respond_to_event :set_filter, :from => me.name
  end
  
  # display and wire the filters.
  def display
    render :locals => {:filter_groups => prepare_filter_display}
  end
    
  # prepare filters for display
  # this is the logic for displaying the filters, leaving the view code relatively sparse
  # TODO: Try to generalize the individual button code so that I don't need such heavy JS
  def prepare_filter_display
    filter_groups = []
    if filter_sequence.size
    	filter_sequence.each do |filter_group|
    	  fg = filters[filter_group]
    	  group_display = {:label => fg[:options][:name], :filters => []}
    		col_max = fg[:options][:columns] || 6
    		current_row = []
    		fg[:sequence].each do |sf|
    		  fid = filter_dom_id(filter_group,sf)
  				filter_display = {:class => "filter filter_onf filter_#{filter_group}",
  				  :id => fid,
  				  :name => fg[:filters][sf][:name],
  				  :wiring => wire_individual_filter(fid, filter_group, sf)
  				}
  				if current_row.size == col_max
  				  group_display[:filters] << current_row
  				  current_row = []
				  end
				  current_row << filter_display
				end
				# pad out the last row with empty cells
				while current_row.size < col_max
				  current_row << {:id => nil}
    		end
    		group_display[:filters] << current_row
    		filter_groups << group_display
  		end
		end
		filter_groups
  end
  
  # Build the Javascript that will highlight the active filters
  # reponse to a :set_filter event generated by a Javascript event, clicking on a filter
  # #grid_reload and #store_filters are defined in jqgrid_support
  def set_filter(evt = nil)
    # Build the set of filter groups that have active filters, and a Javascript string that will highlight actives.
    # In the process, it also collects the string that will be stored 
    # for the grid's data retrieval, and determines whether there are any groups that have
    # no filters selected.
    highlight_active = ''
    filter_parms = []
    groups_active = []
    if active_filters = parent.parse_filters(evt)
      active_filters.each do |group,filter_ids|
        filter_parm = group
        filter_ids.each do |filter_id|
          highlight_active += highlight_active_filter(filter_dom_id(group,filter_id))
          filter_parm += '-' + filter_id.to_s
        end
        filter_parms << filter_parm
        groups_active << group if filter_ids.size > 0
      end
    end
    # Build the Javascript that will turn all the filters in a group to either: neutral if no filters are on,
    # or off, in preparation for turning the active ones on.
    group_style = ''
    filter_sequence.each do |f|
      if groups_active.include?(f)
        group_style += style_filter_group_off(f)
      else
        group_style += style_filter_group_onf(f)
      end
    end
    store_filters = grid_set_post_params('filters' => filter_parms.join('|'))
    render :text => group_style + highlight_active + store_filters + grid_reload
  end
    
  private 
  
  # filter_dom_id returns an id string for a filter, it's used in a couple of places
  def filter_dom_id(filter_group, filter_key)
    "filter_#{dom_id}_#{filter_group}_#{filter_key}"
  end
  
  def wire_individual_filter(fid, filter_group, sf)
    <<-JS
    $('##{fid}').click(function(){
			$.get('#{url_for_event(:set_filter)}', build_filter('##{dom_id}_grid','#{filter_group}','#{sf}'), null, 'script');
      });
    JS
  end
  
  def highlight_active_filter(fdomid)
    <<-JS
    $('##{fdomid}').addClass('filter_on').removeClass('filter_off').removeClass('filter_onf');
    JS
  end
  
  def style_filter_group_off(filter_group)
    <<-JS
    $('##{dom_id}_panel .filter_#{filter_group}').removeClass('filter_on').addClass('filter_off').removeClass('filter_onf');
    JS
  end

  def style_filter_group_onf(filter_group)
    <<-JS
    $('##{dom_id}_panel .filter_#{filter_group}').removeClass('filter_on').removeClass('filter_off').addClass('filter_onf');
    JS
  end
  
  # create local accessors for the configuration options known by the parent
  # seems cleaner to do this somehow
  
  def dom_id
    parent.parent.dom_id
  end
    
  def filters
    parent.parent.filters
  end

  def filter_sequence
    parent.parent.filter_sequence
  end
  
  def filter_default
    parent.parent.filter_default
  end

  def grid_reload
    parent.grid_reload
  end
  
  public :dom_id  # view needs to be able to see this
  
end
